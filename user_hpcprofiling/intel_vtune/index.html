<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/libs/lunr/lunr.min.js"></script> <script src="/libs/lunr/lunr_index.js"></script> <script src="/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_hyde.css"> <link rel=stylesheet  href="/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 1%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/assets/favicon.png"> <title>Intel VTune Profiler + Julia</title> <style> .content {max-width: 60rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <br> <h1><a href="/">Julia On HPC Clusters</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by the Julia HPC community</div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/"><b>Welcome</b></a> <br> <div class=course-section >For Users</div> <a class="sidebar-nav-item " href="/user_gettingstarted/">Getting started</a> <a class="sidebar-nav-item " href="/user_vscode/">Visual Studio Code on HPC Clusters</a> <a class="sidebar-nav-item active" href="/user_hpcprofiling/">HPC profiling tools</a> <a class="sidebar-nav-item " href="/user_hpcsystems/">HPC systems with Julia support</a> <a class="sidebar-nav-item " href="/user_faq/">FAQ</a> <div class=course-section >For System Admins</div> <a class="sidebar-nav-item " href="/sysadmin_julia/">How to provide Julia to users?</a> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=intel_vtune_profiler_julia ><a href="#intel_vtune_profiler_julia" class=header-anchor >Intel VTune Profiler &#43; Julia</a></h1> <hr /> <p><a id=content  class=anchor ></a> <strong>Content</strong></p> <div class=franklin-toc ><ol><li><a href="#general_notes">General notes</a><li><a href="#remote_usage_-_gui">Remote usage - GUI</a><ol><li><a href="#example_code">Example code</a><li><a href="#profiling_via_the_gui">Profiling via the GUI</a><li><a href="#results">Results</a></ol><li><a href="#command-line_interface_cli">Command-line interface &#40;CLI&#41;</a></ol></div> <hr /> <h2 id=general_notes ><a href="#general_notes" class=header-anchor >General notes</a></h2> <ul> <li><p>You need to set <code>ENABLE_JITPROFILING&#61;1</code>.</p> <li><p>For Julia &lt; 1.9, you need to compile Julia from source with <code>USE_INTEL_JITEVENTS&#61;1</code>.</p> </ul> <h2 id=remote_usage_-_gui ><a href="#remote_usage_-_gui" class=header-anchor >Remote usage - GUI</a></h2> <h3 id=example_code ><a href="#example_code" class=header-anchor >Example code</a></h3> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> ThreadPinning
<span class=hljs-keyword >using</span> IntelITT

<span class=hljs-comment ># Multithreaded SAXPY kernel: Y[i] = a * X[i] + Y[i]</span>
<span class=hljs-keyword >function</span> saxpy_kernel(a, X, Y)
    Threads.<span class=hljs-meta >@threads</span> :static <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(Y)
        <span class=hljs-meta >@inbounds</span> Y[i] = a * X[i] + Y[i]
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> <span class=hljs-literal >nothing</span>
<span class=hljs-keyword >end</span>

<span class=hljs-string >&quot;&quot;&quot;
  measure_membw(; kwargs...) -&gt; membw, flops

Estimate the memory bandwidth (GB/s) by performing a time measurement of a
SAXPY kernel. Returns the memory bandwidth (GB/s) and the compute (GFLOP/s).

**Keyword arguments:**
- `pin` (default: `:compact`): pinning strategy (supported by ThreadPinning)
- `init` (default: `:serial`): initialize arrays in serial or in parallel (`:parallel`)
- `N` (default: `1024*100_000``): problem size, i.e. vector length
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> measure_membw(; N = <span class=hljs-number >1024</span> * <span class=hljs-number >100_000</span>)
    bytes = <span class=hljs-number >3</span> * sizeof(<span class=hljs-built_in >Float64</span>) * N <span class=hljs-comment ># num bytes transferred in SAXPY</span>
    flops = <span class=hljs-number >2</span> * N <span class=hljs-comment ># num flops in SAXPY</span>

    <span class=hljs-comment ># pinning the Julia threads</span>
    ThreadPinning.pinthreads(:numa)

    <span class=hljs-comment ># initialize data in parallel</span>
    a = <span class=hljs-number >3.141</span>
    X = <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, N)
    Y = <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, N)
    Threads.<span class=hljs-meta >@threads</span> :static <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(Y)
        X[i] = rand()
        Y[i] = rand()
    <span class=hljs-keyword >end</span>
    
    <span class=hljs-comment ># warmup</span>
    saxpy_kernel(a, X, Y)

    IntelITT.resume()
    t = <span class=hljs-built_in >Float64</span>(<span class=hljs-literal >Inf</span>)
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>
        t_cur = <span class=hljs-meta >@elapsed</span> <span class=hljs-keyword >begin</span>
            saxpy_kernel(a, X, Y)
            saxpy_kernel(a, X, Y)
        <span class=hljs-keyword >end</span>
        t = min(t, t_cur/<span class=hljs-number >2</span>)
    <span class=hljs-keyword >end</span>
    IntelITT.pause()
    
    mem_rate = bytes * <span class=hljs-number >1e-9</span> / t <span class=hljs-comment ># GB/s</span>
    flop_rate = flops * <span class=hljs-number >1e-9</span> / t <span class=hljs-comment ># GFLOP/s</span>

    <span class=hljs-keyword >return</span> mem_rate, flop_rate
<span class=hljs-keyword >end</span>

measure_membw(; pin=:numa, init=:parallel)</code></pre> <h3 id=profiling_via_the_gui ><a href="#profiling_via_the_gui" class=header-anchor >Profiling via the GUI</a></h3> <ul> <li><p>Make sure that you have <strong>password-less SSH access</strong> to the remote machine &#40;e.g. compute node&#41; that you want to profile on. In this example, the name of the remote machine is <code>gpu-0002</code>.</p> <li><p>Start a new analysis. The &quot;Configure Analysis&quot; page should look similar to this:</p> </ul> <p><img src="/user_hpcprofiling/vtunes_saxpy_remoteusage.png" alt="" /></p> <ul> <li><p>Comments</p> <ul> <li><p>The first time, you need to tell Intel VTune to install the necessary software tools for remote profiling via SSH. Just click on the &quot;Deploy&quot; button in the &quot;Remote Linux &#40;SSH&#41;&quot; tile &#40;not shown&#41;. Afterwards, it should look as in the image above.</p> <li><p>I use a little wrapper script <code>julia_vtunes.sh</code> under application. It loads the Julia module on the cluster, sets <code>ENABLE_JITPROFILING&#61;1</code>, and then starts <code>julia</code>.</p> <pre><code class="shell hljs"><span class="hljs-meta prompt_"># </span><span class=language-bash >julia_vtunes.sh</span>

module load lang/JuliaHPC # cluster specific
export ENABLE_JITPROFILING=1
exec julia &quot;${@}&quot;</code></pre> <li><p>Wheter you use a julia wrapper or not, <strong>you must set <code>ENABLE_JITPROFILING&#61;1</code></strong>.</p> <li><p>In the screenshot above, I&#39;ve selected &quot;Hotpots&quot; as the analysis type &#40;right pane&#41;. It&#39;s likely what you want to use.</p> </ul> <li><p>Once everything is configured, press either on &quot;Start&quot; &#40;play button&#41; or on &quot;Start Paused&quot; &#40;play &#43; pause button&#41;. I recommend to use &quot;Start Paused&quot; in conjuction with using <a href="https://github.com/JuliaPerf/IntelITT.jl">IntelITT.jl</a>, i.e. <code>IntelITT.resume&#40;&#41;</code> and <code>IntelITT.pause&#40;&#41;</code>, in your code. This way, you can already pre-select the code region that you actually care about.</p> </ul> <h3 id=results ><a href="#results" class=header-anchor >Results</a></h3> <ul> <li><p>Summary</p> </ul> <p><img src="/user_hpcprofiling/vtunes_saxpy_summary.png" alt="" /></p> <ul> <li><p>Top-down Tree</p> </ul> <p><img src="/user_hpcprofiling/vtunes_saxpy_details.png" alt="" /></p> <ul> <li><p>Comments</p> <ul> <li><p>Due to how Julia works internally, your Julia functions appear with the prefix <code>julia_</code> and a suffix <code>_XX</code>, where <code>XX</code> is a unique number, in the call stack. For example, the Julia function <code>mysquare&#40;x&#41; &#61; x^2</code> might appear as <code>julia_mysquare_89</code>.</p> <li><p>In the SAXPY example above, we use <code>@threads</code>, which, under the hood, <a href="https://github.com/JuliaLang/julia/blob/feb2988b3a21968410267378b910ce67726a51d8/base/threadingconstructs.jl#L169-L204">creates a function <code>threadsfor_fun</code></a> that will then get run &#40;see the top-down tree above&#41;. Unfortunately, this can also cause problems like &quot;cutting off&quot; the call stack information as well as hindering source code resolution.</p> <li><p>Source code resolution &#40;i.e. &quot;View Source&quot;&#41; didn&#39;t work for me remotely. However, it gives you the option to point to the source file locally. This worked fine.</p> </ul> </ul> <h2 id=command-line_interface_cli ><a href="#command-line_interface_cli" class=header-anchor >Command-line interface &#40;CLI&#41;</a></h2> <p>Useful commands:</p> <ul> <li><p>Profiling: <code>ENABLE_JITPROFILING&#61;1 vtune -collect hotspots -start-paused -- julia --project mycode.jl</code></p> <li><p>Open the results in the GUI: <code>vtune-gui r000hs</code></p> <li><p>Generating text reports:</p> </ul> <pre><code class="shell hljs">vtune -report hotspots -r r000hs -group-by source-line &gt; reports/hotspots.report
vtune -report top-down -r r000hs &gt; reports/top_down.report
vtune -report callstacks -r r000hs &gt; reports/callstacks.report</code></pre> <p>Check out the <a href="https://github.com/carstenbauer/julia-intelvtune">julia-intelvtune repository</a> by Carsten Bauer which contains a basic demonstration.</p> <div class=page-foot > <div class=copyright > <a href="https://github.com/JuliaHPC/juliahpc.github.io/"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br> Last modified: July 20, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div>